#include <stdlib.h>  // Ётот include не нужен дл€ этого кода.
#include <iostream>

// Ёта программа создана дл€ иллюстрации работы стека.
// ¬ ней демонстрируетс€ поведение локальных переменных и указателей.
// ќднако она также демонстрирует неопределенное поведение, что не рекомендуетс€ в практике.

int* stackMemory1()
{
    int a = 1;          // ќбъ€вл€ем целочисленную переменную 'a' со значением 1 в стеке.
    return &a;          // ¬озвращаем указатель на 'a'. Ёто проблематично.
}

int* stackMemory2()
{
    int b = 2;          // ќбъ€вл€ем целочисленную переменную 'b' со значением 2 в стеке.
    return &b;          // ¬озвращаем указатель на 'b'. Ёто тоже проблематично.
}

int main()
{
    int* b = stackMemory1();   // 'b' указывает на адрес пам€ти 'a'.
    int a1 = *b;               // Ёто нормально, так как 'b' все ещЄ указывает на 'a' в пределах области видимости stackMemory1.

    int* c = stackMemory2();   // 'c' указывает на адрес пам€ти 'b'.
    int a2 = *c;               // Ёто нормально, так как 'c' все ещЄ указывает на 'b' в пределах области видимости stackMemory2.

    int a3 = *b;               // Ёто проблематично, так как 'b' теперь указывает на 'b' из stackMemory2. Ёто неопределенное поведение.

    std::cout << a1 << std::endl;   // ¬ыводит 1
    std::cout << a2 << std::endl;   // ¬ыводит 2
    std::cout << a3 << std::endl;   // ¬ыводит 2 (хот€ это значение неопределено и может варьироватьс€)
    std::cout << ((std::byte*)b - (std::byte*)c) << std::endl;  // ¬ыводит 0, указыва€ на то, что 'b' и 'c' указывают на одно и то же место в пам€ти.

    return 0;
}
